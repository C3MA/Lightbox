   1               		.file	"main.c"
   2               		.arch atmega8
   3               	__SREG__ = 0x3f
   4               	__SP_H__ = 0x3e
   5               	__SP_L__ = 0x3d
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.global __do_copy_data
   9               		.global __do_clear_bss
  12               		.text
  13               	.Ltext0:
  80               		.lcomm gProgrammode,1
  81               		.lcomm gId,1
  82               		.data
  83               	.LC0:
  84 0000 4861 6C6C 		.string	"Hallo Welt\r\n"
  84      6F20 5765 
  84      6C74 0D0A 
  84      00
  85               		.text
  87               	.global	main
  89               	main:
  90               		.stabd	46,0,0
   0:main.c        **** #include <avr/io.h>
   1:main.c        **** #include <avr/interrupt.h>
   2:main.c        **** #include <avr/sleep.h>
   3:main.c        **** #include <stdint.h>
   4:main.c        **** #include <inttypes.h>
   5:main.c        **** #include <stdlib.h>	// for itoa() call
   6:main.c        **** #include <string.h>	// for memset() call
   7:main.c        **** #include "uart.h"	// this functions needs exact this UART-lib, because this one writes the inputdat
   8:main.c        **** #include "timer.h"
   9:main.c        **** #include "util.h"
  10:main.c        **** 
  11:main.c        **** /************* Configuration **************/
  12:main.c        **** //#define BIDIRECTIONAL	// When this is defined, the uC will answer, too.
  13:main.c        **** 
  14:main.c        **** #define UART_BAUD_RATE      57600UL //Definition als unsigned long, sonst gibt es Fehler in der Ber
  15:main.c        **** 
  16:main.c        **** #define DELAY 90000
  17:main.c        **** 
  18:main.c        **** 
  19:main.c        **** /************* Logic **************/
  20:main.c        **** 
  21:main.c        **** #define COMMAND_LENGTH 10
  22:main.c        **** 
  23:main.c        **** #ifdef BIDIRECTIONAL
  24:main.c        **** 	#define MSG(a) uart_send_s(a);
  25:main.c        **** #else
  26:main.c        **** 	#define MSG(a)	;
  27:main.c        **** #endif
  28:main.c        **** 
  29:main.c        **** static char gCommand[COMMAND_LENGTH];
  30:main.c        **** static uint8_t gProgrammode=0;
  31:main.c        **** 
  32:main.c        **** static uint8_t gId = 0;
  33:main.c        **** 
  34:main.c        **** static void fillActualCommand(void);
  35:main.c        **** 
  36:main.c        **** int main(void)
  37:main.c        **** {
  92               	.LM0:
  93               	/* prologue: frame size=0 */
  94 0000 C0E0      		ldi r28,lo8(__stack - 0)
  95 0002 D0E0      		ldi r29,hi8(__stack - 0)
  96 0004 DEBF      		out __SP_H__,r29
  97 0006 CDBF      		out __SP_L__,r28
  98               	/* prologue end (size=4) */
  38:main.c        **** // Pindefenition	
  39:main.c        **** 	cli();
 100               	.LM1:
 101               	/* #APP */
 102 0008 F894      		cli
  40:main.c        **** 	DDRD = (1<<PD6)|(1<<PD5);
 104               	.LM2:
 105               	/* #NOAPP */
 106 000a 80E6      		ldi r24,lo8(96)
 107 000c 81BB      		out 49-0x20,r24
  41:main.c        **** 	PORTD = 0x00;
 109               	.LM3:
 110 000e 12BA      		out 50-0x20,__zero_reg__
  42:main.c        **** 	PIND = 0x00;
 112               	.LM4:
 113 0010 10BA      		out 48-0x20,__zero_reg__
  43:main.c        **** 	PORTD |= (1 << PD6);
 115               	.LM5:
 116 0012 969A      		sbi 50-0x20,6
  44:main.c        **** 	uart_init_own( UART_BAUD_SELECT(UART_BAUD_RATE,F_CPU) );
 118               	.LM6:
 119 0014 87E0      		ldi r24,lo8(7)
 120 0016 90E0      		ldi r25,hi8(7)
 121 0018 00D0      		rcall uart_init_own
  45:main.c        **** 
  46:main.c        **** // Interrupt fÃ¼r INT1 und INT0 intialisieren
  47:main.c        **** 	MCUCR |= 0x0F;
 123               	.LM7:
 124 001a 85B7      		in r24,85-0x20
 125 001c 8F60      		ori r24,lo8(15)
 126 001e 85BF      		out 85-0x20,r24
  48:main.c        **** 	
  49:main.c        **** 	sei();
 128               	.LM8:
 129               	/* #APP */
 130 0020 7894      		sei
  50:main.c        **** 	
  51:main.c        **** 	
  52:main.c        **** 	/********* PWD *********/
  53:main.c        **** 	DDRB  = 0xff;                  // use all pins on PortB for output 
 132               	.LM9:
 133               	/* #NOAPP */
 134 0022 8FEF      		ldi r24,lo8(-1)
 135 0024 87BB      		out 55-0x20,r24
  54:main.c        ****     PORTB = 0xff;                  // set output high -> turn all LEDs off
 137               	.LM10:
 138 0026 88BB      		out 56-0x20,r24
  55:main.c        **** 	// set OC1A pin as output, required for output toggling
  56:main.c        ****     DDRB |= _BV(PB1); // red
 140               	.LM11:
 141 0028 B99A      		sbi 55-0x20,1
  57:main.c        **** 	DDRB |= _BV(PB2); // green
 143               	.LM12:
 144 002a BA9A      		sbi 55-0x20,2
  58:main.c        **** 	DDRB |= _BV(PB3); // blue
 146               	.LM13:
 147 002c BB9A      		sbi 55-0x20,3
  59:main.c        **** 	
  60:main.c        **** 	/* PWM-Quelle: http://www.mikrocontroller.net/topic/158322 */
  61:main.c        **** 	
  62:main.c        **** 	// Init Pins
  63:main.c        **** 	PORTB &=~ ((1 << PB1)  | (1 << PB2)  | (1 << PB3));  
 149               	.LM14:
 150 002e 88B3      		in r24,56-0x20
 151 0030 817F      		andi r24,lo8(-15)
 152 0032 88BB      		out 56-0x20,r24
  64:main.c        **** 	DDRB  |=  ((1 << DDB1) | (1 << DDB2) | (1 << DDB3));  
 154               	.LM15:
 155 0034 87B3      		in r24,55-0x20
 156 0036 8E60      		ori r24,lo8(14)
 157 0038 87BB      		out 55-0x20,r24
  65:main.c        **** 	
  66:main.c        **** 	// Init PWM Systems
  67:main.c        **** 	TCCR1A |= (1 << COM1A1) | (1 << COM1A0) | (1 << COM1B1) | (1 << COM1B0) | (1 << WGM10);
 159               	.LM16:
 160 003a 8FB5      		in r24,79-0x20
 161 003c 816F      		ori r24,lo8(-15)
 162 003e 8FBD      		out 79-0x20,r24
  68:main.c        **** 	TCCR1B |= (1 << CS10);
 164               	.LM17:
 165 0040 8EB5      		in r24,78-0x20
 166 0042 8160      		ori r24,lo8(1)
 167 0044 8EBD      		out 78-0x20,r24
  69:main.c        **** 	TCCR2  |= (1 << COM21) | (1 << COM20) | (1 << WGM20) | (1 << CS20);
 169               	.LM18:
 170 0046 85B5      		in r24,69-0x20
 171 0048 8167      		ori r24,lo8(113)
 172 004a 85BD      		out 69-0x20,r24
  70:main.c        **** 	
  71:main.c        **** 	int red, green, blue, id;
  72:main.c        **** 	int i;
  73:main.c        **** 	
  74:main.c        **** 	PORTD |= (1 << PD5);
 174               	.LM19:
 175 004c 959A      		sbi 50-0x20,5
  75:main.c        **** 	uart_send_s("Hallo Welt\r\n");
 177               	.LM20:
 178 004e 80E0      		ldi r24,lo8(.LC0)
 179 0050 90E0      		ldi r25,hi8(.LC0)
 180 0052 00D0      		rcall uart_send_s
 181               	.L19:
 182               	.LBB2:
 183               	.LBB3:
  76:main.c        **** 
  77:main.c        **** 	while(1) {
  78:main.c        **** 		// Check if programm-button was pressed. (see: gProgrammode)
  79:main.c        **** 				
  80:main.c        **** 		
  81:main.c        **** 		fillActualCommand();
  82:main.c        **** 		
  83:main.c        **** 		switch (gCommand[1]) {
  84:main.c        **** 			case 'w': // check for an "w" as write
  85:main.c        **** 				id = decodeHex(gCommand[8],gCommand[9]);
  86:main.c        **** 				if (gId != id)
  87:main.c        **** 					continue;
  88:main.c        **** 				red = decodeHex(gCommand[2],gCommand[3]);
  89:main.c        **** 				green = decodeHex(gCommand[4],gCommand[5]);
  90:main.c        **** 				blue = decodeHex(gCommand[6],gCommand[7]);
  91:main.c        **** 				MSG("new colorvalues are set.\r\n");
  92:main.c        **** 				MSG(gCommand);
  93:main.c        **** 				MSG("\r\n");
  94:main.c        **** 				break;
  95:main.c        **** 			case 'i': // check for an "i" as initialize
  96:main.c        **** 				//TODO logic!
  97:main.c        **** 				if (gProgrammode == 0)
  98:main.c        **** 				{
  99:main.c        **** 					MSG("Initialize mode is not set!\r\n");
 100:main.c        **** 					continue;
 101:main.c        **** 				}
 102:main.c        **** 				break;
 103:main.c        **** 			default:
 104:main.c        **** 				MSG("Unknown Parameter\r\n");
 105:main.c        **** 				break;
 106:main.c        **** 		}
 107:main.c        **** 		
 108:main.c        **** 		// do the pwm
 109:main.c        **** 		OCR1AL = 0xFF - red;
 110:main.c        **** 		OCR1BL = 0xFF - green;
 111:main.c        **** 		OCR2   = 0xFF - blue;		
 112:main.c        **** 		//delayMicros(DELAY); // Sleep one Second
 113:main.c        **** 	};
 114:main.c        **** }
 115:main.c        **** 
 116:main.c        **** /*
 117:main.c        ****  Command:
 118:main.c        ****  pwRRGGBBid							e.g. pw00FF0001
 119:main.c        ****  pi0000NNid	<- NN = new device id
 120:main.c        ****  Fill the serial input buffer into the gCommand value
 121:main.c        ****  */
 122:main.c        **** static void fillActualCommand(void)
 123:main.c        **** {
 124:main.c        **** 	int i;
 125:main.c        **** 	unsigned int c;
 126:main.c        **** 	
 127:main.c        **** 	// Clear the buffer
 128:main.c        **** 	memset(gCommand, 0, COMMAND_LENGTH);
 185               	.LM21:
 186 0054 E0E0      		ldi r30,lo8(gCommand)
 187 0056 F0E0      		ldi r31,hi8(gCommand)
 188 0058 8AE0      		ldi r24,lo8(10)
 189 005a DF01      		movw r26,r30
 190 005c 1D92      		st X+,__zero_reg__
 191 005e 8A95      	        dec r24
 192 0060 01F4      		brne .-6
 193 0062 00E0      		ldi r16,lo8(0)
 194 0064 10E0      		ldi r17,hi8(0)
 195 0066 EF01      		movw r28,r30
 196               	.L3:
 129:main.c        **** 	
 130:main.c        **** 	for(i = 0; i < COMMAND_LENGTH; i++) {
 131:main.c        **** 		c = uart_getc();
 198               	.LM22:
 199 0068 00D0      		rcall uart_getc
 132:main.c        **** 		if ( c & UART_NO_DATA ) {
 201               	.LM23:
 202 006a 90FF      		sbrs r25,0
 203 006c 00C0      		rjmp .L4
 133:main.c        **** 			// decrement, so the actual position could be filled at the next time.
 134:main.c        **** 			i--;
 205               	.LM24:
 206 006e 0150      		subi r16,lo8(-(-1))
 207 0070 1040      		sbci r17,hi8(-(-1))
 208 0072 2197      		sbiw r28,1
 209 0074 00C0      		rjmp .L6
 210               	.L4:
 135:main.c        **** 		} else {
 136:main.c        **** 			gCommand[i] = c;
 212               	.LM25:
 213 0076 8883      		st Y,r24
 137:main.c        **** 			
 138:main.c        **** 			// check if command begins with a "p"
 139:main.c        **** 			if (gCommand[0] != 'p')
 215               	.LM26:
 216 0078 8091 0000 		lds r24,gCommand
 217 007c 8037      		cpi r24,lo8(112)
 218 007e 01F4      		brne .L7
 219               	.L6:
 131:main.c        **** 	for(i = 0; i < COMMAND_LENGTH; i++) {
 221               	.LM27:
 222 0080 0F5F      		subi r16,lo8(-(1))
 223 0082 1F4F      		sbci r17,hi8(-(1))
 224 0084 2196      		adiw r28,1
 225 0086 0A30      		cpi r16,10
 226 0088 1105      		cpc r17,__zero_reg__
 227 008a 04F0      		brlt .L3
 228               	.L7:
 229               	.LBE3:
 230               	.LBE2:
  84:main.c        **** 		switch (gCommand[1]) {
 232               	.LM28:
 233 008c 8091 0000 		lds r24,gCommand+1
 234 0090 8936      		cpi r24,lo8(105)
 235 0092 01F0      		breq .L9
 236 0094 8737      		cpi r24,lo8(119)
 237 0096 01F4      		brne .L8
  86:main.c        **** 				id = decodeHex(gCommand[8],gCommand[9]);
 239               	.LM29:
 240 0098 6091 0000 		lds r22,gCommand+9
 241 009c 8091 0000 		lds r24,gCommand+8
 242 00a0 00D0      		rcall decodeHex
  87:main.c        **** 				if (gId != id)
 244               	.LM30:
 245 00a2 2091 0000 		lds r18,gId
 246 00a6 3327      		clr r19
 247 00a8 2817      		cp r18,r24
 248 00aa 3907      		cpc r19,r25
 249 00ac 01F4      		brne .L19
  89:main.c        **** 				red = decodeHex(gCommand[2],gCommand[3]);
 251               	.LM31:
 252 00ae 6091 0000 		lds r22,gCommand+3
 253 00b2 8091 0000 		lds r24,gCommand+2
 254 00b6 00D0      		rcall decodeHex
 255 00b8 5C01      		movw r10,r24
  90:main.c        **** 				green = decodeHex(gCommand[4],gCommand[5]);
 257               	.LM32:
 258 00ba 6091 0000 		lds r22,gCommand+5
 259 00be 8091 0000 		lds r24,gCommand+4
 260 00c2 00D0      		rcall decodeHex
 261 00c4 6C01      		movw r12,r24
  91:main.c        **** 				blue = decodeHex(gCommand[6],gCommand[7]);
 263               	.LM33:
 264 00c6 6091 0000 		lds r22,gCommand+7
 265 00ca 8091 0000 		lds r24,gCommand+6
 266 00ce 00D0      		rcall decodeHex
 267 00d0 7C01      		movw r14,r24
 268 00d2 00C0      		rjmp .L8
 269               	.L9:
  98:main.c        **** 				if (gProgrammode == 0)
 271               	.LM34:
 272 00d4 8091 0000 		lds r24,gProgrammode
 273 00d8 8823      		tst r24
 274 00da 01F4      		brne .+2
 275 00dc 00C0      		rjmp .L19
 276               	.L8:
 110:main.c        **** 		OCR1AL = 0xFF - red;
 278               	.LM35:
 279 00de 8A2D      		mov r24,r10
 280 00e0 8095      		com r24
 281 00e2 8ABD      		out 74-0x20,r24
 111:main.c        **** 		OCR1BL = 0xFF - green;
 283               	.LM36:
 284 00e4 8C2D      		mov r24,r12
 285 00e6 8095      		com r24
 286 00e8 88BD      		out 72-0x20,r24
 112:main.c        **** 		OCR2   = 0xFF - blue;		
 288               	.LM37:
 289 00ea 8E2D      		mov r24,r14
 290 00ec 8095      		com r24
 291 00ee 83BD      		out 67-0x20,r24
 292 00f0 00C0      		rjmp .L19
 293               	/* epilogue: frame size=0 */
 294               	/* epilogue: noreturn */
 295               	/* epilogue end (size=0) */
 296               	/* function main size 123 (119) */
 303               	.Lscope0:
 305               		.stabd	78,0,0
 309               		.lcomm gCommand,10
 311               	.Letext0:
 312               	/* File "main.c": code  123 = 0x007b ( 119), prologues   4, epilogues   0 */
DEFINED SYMBOLS
                            *ABS*:0000000000000000 main.c
/var/folders/EC/ECbZtGXfFZWjidEwY+C4q++++TM/-Tmp-//cchwsPJX.s:3      *ABS*:000000000000003f __SREG__
/var/folders/EC/ECbZtGXfFZWjidEwY+C4q++++TM/-Tmp-//cchwsPJX.s:4      *ABS*:000000000000003e __SP_H__
/var/folders/EC/ECbZtGXfFZWjidEwY+C4q++++TM/-Tmp-//cchwsPJX.s:5      *ABS*:000000000000003d __SP_L__
/var/folders/EC/ECbZtGXfFZWjidEwY+C4q++++TM/-Tmp-//cchwsPJX.s:6      *ABS*:0000000000000000 __tmp_reg__
/var/folders/EC/ECbZtGXfFZWjidEwY+C4q++++TM/-Tmp-//cchwsPJX.s:7      *ABS*:0000000000000001 __zero_reg__
                             .bss:0000000000000000 gProgrammode
/var/folders/EC/ECbZtGXfFZWjidEwY+C4q++++TM/-Tmp-//cchwsPJX.s:80     .bss:0000000000000001 gId
/var/folders/EC/ECbZtGXfFZWjidEwY+C4q++++TM/-Tmp-//cchwsPJX.s:89     .text:0000000000000000 main
/var/folders/EC/ECbZtGXfFZWjidEwY+C4q++++TM/-Tmp-//cchwsPJX.s:81     .bss:0000000000000002 gCommand

UNDEFINED SYMBOLS
__do_copy_data
__do_clear_bss
__stack
uart_init_own
uart_send_s
uart_getc
decodeHex
